#!/usr/bin/env python3

import sys
from collections import defaultdict
import os

machines = []
tasks = []
time_slices = []

class Machine:
    def __init__(self, id : int):
        self.id = id
    
    def __str__(self) -> str:
        return f'm_{self.id}'

class TimeSlice:
    def __init__(self, id : int):
        self.id = id
        self.end = id + 1
    
    def __str__(self) -> str:
        return f't_{self.id}'

class Task:
    def __init__(self, machine_id : int, job_number : int, length: int, absolute_first = False, other_first = False):
        self.machine_id = machine_id
        self.job_number = job_number
        self.length = length
        self.absolute_first = absolute_first
        self.other_first = other_first
    
    def __str__(self) -> str:
        return f'task_{self.job_number}_{self.machine_id}'

def read_file():
    machine_count = int(sys.stdin.readline().split()[1])
    for i in range(1,machine_count+1):
        machines.append(Machine(i))

    job_count = 1
    for line in sys.stdin:
        line = line.rstrip()
        items = line.split()
        number_machines = int(items[0])

        first_split_task = items[1].split(":")
        
        tasks.append(Task(0, job_count, 1, absolute_first=True))

        for task in line.split()[1:]:
            split_task = task.split(":")
            machine = int(split_task[0])
            task_count = int(split_task[1])
            tasks.append(Task(machines[machine-1].id, job_count, task_count, other_first=True))
            # for i in range(2, task_count+1):
            #     tasks.append(Task(machines[machine-1], job_count,i))
        job_count += 1


def define(file, job_name: str, domain_name: str):
    file.write(f'(define (problem {job_name}) (:domain {domain_name})\n')

def objects(file):
    file.write("(:objects \n\t")

    for task in tasks:
        file.write(str(task) + " ")
    file.write("- task\n\t")

    for time_slice in time_slices:
        file.write(str(time_slice) + " ")
    file.write("- time_slice\n\t")

    for machine in machines:
        file.write(str(machine)+ " ")
    file.write("- machine\n)\n")

def init(file):
    file.write("(:init\n")

    # task declarations
    previous_task = None
    for task in tasks:

        if task.absolute_first:
            file.write(f'\t(scheduled {task})\n')
            #file.write(f'\t(other_first_task {task})\n')
            #file.write(f'\t(task_is_last {previous_task})\n')
        #elif task.other_first:
            #file.write(f'\t(other_first_task {task})\n')
            #file.write(f'\t(task_is_last {previous_task})\n')

        if previous_task and task.job_number == previous_task.job_number:
            file.write(f'\t(task_precedes {previous_task} {task})\n')

            
        file.write(f'\t(is_for {task} {machines[task.machine_id-1]})\n\n')
        previous_task = task
    
    #file.write(f'\t(task_is_last {previous_task})\n')


    # time slice declarations
    previous_ts = None
    for time_slice in time_slices:
        for task in tasks:
            ts_end = time_slice.id + task.length
            if ts_end <=  len(time_slices): 
                file.write(f'\t(tasks_separated_by {task} {time_slice} {time_slices[ts_end - 1]})\n')

        # if previous_ts:
        #     file.write(f'\t(adjacent {previous_ts} {time_slice})\n')
        
        biggest_size = 0
        for task in tasks:
            if task.length > biggest_size:
                biggest_size = task.length

        for time_slice_inner in time_slices:
            if time_slice_inner.id > time_slice.id:
                file.write(f'\t(ts_precedes {time_slice} {time_slice_inner})\n')
            
        file.write(f'\t(=(end {time_slice}) {time_slice.end})\n\n')

        previous_ts = time_slice

    file.write("\t(=(total_cost) 0)\n")
    file.write(")\n")
    

def goal(file):
    file.write("(:goal (and\n")
    for task in tasks:
        if not task.absolute_first:
            file.write(f'\t(scheduled {task})\n')
    file.write("))\n")


def metric(file):
    file.write("(:metric minimize (total-cost))\n)")


def write_domain():
    f = open("domain.pddl", "w")
    f.write("(define (domain job_schedule_domain) \n\t(:requirements :adl :action-costs :existential-preconditions) \n\t(:types task machine time_slice) \n\t(:predicates  \n\t\t(is_for ?t - task ?m - machine) \n\t\t(task_precedes ?t1 ?t2 - task) \n\t\t(ts_precedes ?ts1 ?ts2 - time_slice) \n\t\t(ts_occupied ?m - machine ?ts1 - time_slice) \n\t\t(scheduled ?t - task) \n\t\t(tasks_separated_by ?t - task ?ts1 ?ts2 - time_slice) \n\t\t(task_occupies_ts ?t - task ?ts - time_slice) ) \n\t(:functions     \n\t\t(end ?ts - time_slice)- number      \n\t\t(total-cost) - number    ) \n\t(:action schedule_middle_sub_task\n\t\t:parameters (?m - machine ?task ?pre_task - task  ?time_slice ?end_time_slice - time_slice)\n\t\t:precondition (and  \n\t\t\t\t(not (scheduled ?task))\n\t\t\t\t(tasks_separated_by ?task ?time_slice ?end_time_slice)\n\t\t\t\t(scheduled ?pre_task)\n\t\t\t\t(is_for ?task ?m)\n\t\t\t\t(not (ts_occupied ?m ?time_slice))\n\t\t\t\t(not (task_occupies_ts ?pre_task ?time_slice))\n\t\t\t\t(not (exists (?ts - time_slice)\n\t\t\t\t\t(and (ts_precedes ?time_slice ?ts) (ts_occupied ?m ?ts))\n\t\t\t\t))\n\t\t\t\t(not (exists (?ts - time_slice)\n\t\t\t\t\t(and (ts_precedes ?time_slice ?ts) (task_occupies_ts ?pre_task ?ts))\n\t\t\t\t))\n\t\t\t\t(task_precedes ?pre_task ?task)\n\t\t\t\t)     \n\t:effect (and\n\t\t\t\t (scheduled ?task)\n\t\t\t\t(ts_occupied ?m ?time_slice)\n\t\t\t\t(ts_occupied ?m ?end_time_slice)\n\t\t\t\t(task_occupies_ts ?task ?time_slice)\n\t\t\t\t(task_occupies_ts ?task ?end_time_slice)\n\t\t\t\t(increase (total-cost) (end ?end_time_slice))\n\t\t\t\t)))")
    f.close()
if __name__  == "__main__":
    write_domain()

    read_file()

    sum = 0
    for task in tasks:
        sum += task.length
    # Create time slices

    if(sum > 20):
        if len(machines) > 7:
            sum = sum * 0.5
        else:
            sum = sum*0.75

    for i in range(int(sum)):
        time_slices.append(TimeSlice(i))
    
    f = open("generated_problem.pddl", "w")
    f.writelines

    define(f, "jobs", "job_schedule_domain")
    objects(f)
    init(f)
    goal(f)
    metric(f)

    f.close()

    search = ""
    if sum < 20:
        os.system("./downward/fast-downward.py --alias seq-sat-lama-2011 domain.pddl generated_problem.pddl > /dev/null 2>&1 ")
        search = "lama"
    else:
        #os.system("./downward/fast-downward.py domain.pddl generated_problem.pddl --search 'astar(blind())'")
        #os.system("./downward/fast-downward.py domain.pddl generated_problem.pddl --evaluator 'hff=ff()' --evaluator 'hff2=ff(transform=adapt_costs(plusone))' --evaluator 'hlm2=lmcount(lm_reasonable_orders_hps(lm_rhw()),transform=adapt_costs(plusone),pref=true)' --search 'lazy_wastar([hff2, hlm2), preferred = [hff(), hlm2()], w = 1)'")
        os.system("./downward/fast-downward.py domain.pddl generated_problem.pddl --search 'lazy_greedy([ff()], preferred=[ff()])' > /dev/null 2>&1 ")
        search = "astar"


    last_index = -1
    if search == "lama":
        for file in os.listdir():
            if file.find("sas_plan") != -1:
                split = file.split(".")
                if int(split[1]) > last_index:
                    last_index = int(split[1])
    
    if(search == "lama"):
        f = open("sas_plan." + str(last_index), "r")
    else:
        f = open("sas_plan", "r")
    
  
    jobs = []
    
    for task in tasks:
        if task.job_number not in jobs:
            jobs.append(task.job_number)
            
    
    f.close()

    if(search == "lama"):
        f = open("sas_plan." + str(last_index), "r")
    else:
        f = open("sas_plan", "r")

    things = defaultdict(list)

    time_taken = -1
    for line in f:
        split = line.split()
        if split[0] == "(schedule_middle_sub_task":
            machine_id = int(split[1].split("_")[1])
            job_number = int(split[2].split("_")[1])
            time_started = int(split[4].split("_")[1])
            time_ended = int(split[5].replace(")", "").split("_")[1])


        things[job_number].append([machine_id, time_started])

        if time_ended > time_taken:
            time_taken = time_ended


    time_taken += 1
    print(time_taken)
    print(str(len(jobs)) + " " + str(len(machines)))


    for i in range(len(jobs)):
        start_times = dict()
        for item in things[i+1]:
            if item[0] not in start_times:
                start_times[item[0]] = item[1]
            elif item[1] < start_times[item[0]]:
                start_times[item[0]] = item[1]
        #print(start_times)
        sys.stdout.write(str(len(start_times.keys())) + " ")
        for key, value in start_times.items():
            sys.stdout.write(str(key) + ":" + str(value) + " ")
        sys.stdout.write("\n")
    f.close()    

    #Cleanup
    os.system("rm sas_plan*")
    os.system("rm generated_problem.pddl")
    #os.system("rm domain.pddl")






                






